<!DOCTYPE html>
<html>

<head>
    <title>Markweave OT Demo</title>
</head>

<body>
    <h3>协同编辑 Demo</h3>
    <p>版本号: <span id="version">0</span></p>
    <div id="container" style="height: 100%"></div>

    <script type="module">
        import * as monaco from './node_modules/monaco-editor/esm/vs/editor/editor.api';
        const editor = document.getElementById('container');
        monaco.editor.create(editor,{value : '1231'})
        const verSpan = document.getElementById('version');
        const clientId = "user_" + Math.random().toString(16).slice(2);
        let currentVersion = 0;

        class queue {
            constructor(k) {
                this.size = 0;
                this.queue = new Array(k);
                this.front = 0;
                this.end = 0;
                this.cap = k;
            }
            cap() {
                return this.size
            }
            push(x) {
                this.queue[this.end] = x;
                this.end = (this.end + 1) % this.cap;
                this.size++;
            }
            popFront() {
                let val = this.queue[this.front];
                this.front = (this.front + 1) % this.cap;
                this.size--;
                return val; 
            }
            [Symbol.iterator]() {
                let cnt = 0;
                let size = this.size;
                let front = this.front;
                let cap = this.cap;
                return {
                    next: () => {
                        if (cnt < size) {
                            const val = this.queue[front];
                            front = (front + 1) % cap;
                            cnt++;
                            return { value : val, done: false };
                        } else {
                            return { done: true };
                        }
                    }
                }
            }
        }
        //停等队列（我遇到了一个问题，在共同的3版本下，如果b发送操作B1,a发送操作A1,A2，服务器收到的是，B1，A1,版本更迭为4，5，但是对于A2操作，在变幻时应当跳过5。所以A2操作需要在前端transform，并等待A1版本号）
        const waitQueue = new queue(1024);
        //缓冲槽
        const bufferMap = {}
        //当前光标位置
        var curPos = 0;

        var waitStatus = false;

        const ws = new WebSocket("ws://localhost:8080/ws/collaboration");


        editor.disabled = true;

        editor.addEventListener('input', (e) => {
            let op;
            if (e.inputType === "deleteContentBackward") {
                op = {
                    type: "DELETE",
                    pos: editor.selectionStart
                }
            }
            else {
                const char = e.data || "" ;
                op = {
                    type: "INSERT",
                    pos: editor.selectionStart - char.length,
                    text: char 
                };
            }
            let msg = {
                clientId: clientId,
                version: currentVersion,
                op: op
            };
            if (waitStatus) waitQueue.push(msg);
            else {
                waitStatus = true;
                ws.send(JSON.stringify(msg));
            }
        });

        let transform = (targetOp,basisOp) => {
            const t = targetOp;
            const b = basisOp;

            if (b.type === "INSERT") {
                if (b.pos <= t.pos) {
                    t.pos += b.text.length;
                }
            } else if (b.type === "DELETE") {
                if (b.pos < t.pos) {
                    t.pos -= 1; // 假设一次删一个
                    t.pos = Math.max(0, t.pos);
                } else if (b.pos === t.pos && t.type === "DELETE") {
                    // 两个人都删了同一个地方，target 设为无效操作
                    t.type = "NOOP";
                }
            }
        }



        let updateDoc = (msg) => {
            currentVersion = msg.version;
            verSpan.textContent = currentVersion;
            //等待队列收到ack允许发送，停等协议
            if (msg.clientId === clientId) {
                waitStatus = false;
                if (waitQueue.size === 0) return;
                waitStatus = true;
                let nextMsg = waitQueue.popFront();
                nextMsg.version = currentVersion;
                ws.send(JSON.stringify(nextMsg));
                return;
            }
            //施加文本操作
            const oldText = editor.value;
            const {pos , type , text}  = msg.op;
            let newText = "";
            if(type === "INSERT"){
                newText = oldText.slice(0,pos) + text + oldText.slice(pos);
            }else if(type ==="DELETE"){
                newText = oldText.slice(0,pos) + oldText.slice(pos+1);
            }
            editor.value = newText;


            //修正光标位置            
            curPos = editor.selectionStart;
            if (type === "INSERT") {
                if (pos <= curPos) {
                    curPos+=text.length;
                }
            } else if (type === "DELETE") {
                if (pos < curPos) {
                    curPos--;
                    curPos = Math.max(curPos, 0);
                }
            }
            //还原指针位置
            editor.setSelectionRange(curPos,curPos);

            //前端的等待队列需要不断变换
            for (let oldMsg of waitQueue) {
                transform(oldMsg.op, msg.op);
            }
        };



        ws.onmessage = (e) => {
            const msg = JSON.parse(e.data);
            if (msg.method === "get_new") {
                currentVersion = msg.version;
                verSpan.textContent = currentVersion;
                editor.value = msg.text;
                editor.disabled = false;
                return
            }
            // 过时广播直接忽略
            if (msg.version <= currentVersion) return
            if (msg.version > currentVersion + 1) {
                bufferMap[msg.version] = msg
            } else {
                updateDoc(msg);
                while (bufferMap[currentVersion + 1] != null) {
                    let nextMsg = bufferMap[currentVersion + 1];
                    delete bufferMap[currentVersion + 1];
                    updateDoc(nextMsg);
                }
            }
        };


        ws.onopen = () => {
            //上线时，获取最新版本
            ws.send(
                JSON.stringify({
                    docId: "123",
                    method: "get_new"
                })
            )
            //如果没有获取最新版本前不允许编辑
            editor.disabled = true;


        }
        setInterval(() => {
            const versions = Object.keys(bufferMap);
            if(versions.length === 0) return ;
            console.warn("检测到版本断档，请求补发...");
            ws.send(JSON.stringify({
                "method" : "pull_history",
                "version" : currentVersion
            }))
        },5000);




    </script>
</body>

</html>