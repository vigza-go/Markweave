# 文档存储方案（替代直接存 `LONGTEXT`）

## 当前问题
- 当前 `doc.content` 使用 `LONGTEXT` 直接保存整篇文档，任意小改动都会触发整字段更新。
- 在高频协同编辑场景中，这会放大写放大（Write Amplification）、Binlog 压力与锁竞争。
- 版本回溯、审计与冲突诊断缺少结构化事件数据。

## 推荐方案：`快照 + 操作日志（Event Sourcing Lite）`

### 1) 在线读写层（保持高性能）
- Redis 继续作为协同会话的热数据层：
  - `doc:text:{docId}`：当前全文（热缓存）
  - `doc:version:{docId}`：当前版本
  - `doc:history:{docId}`：近期 OT 操作窗口
- 协同写入路径仍先落 Redis，再异步持久化，保证交互低延迟。

### 2) 持久化层（MySQL）
- 不再每次都整篇覆盖 `doc.content`，改为两层：
  - **快照表 `doc_snapshot`**（稀疏写入）
    - `doc_id`, `version`, `content`, `created_at`
    - 按版本间隔（如每 100~300 次操作）或时间窗口（如 1~5 分钟）落一份快照。
  - **操作表 `doc_op_log`**（增量写入）
    - `doc_id`, `version`, `client_id`, `op_json`, `created_at`, `trace_id`
    - 每次 OT 最终操作只追加一条日志（Append Only）。

### 3) 读取与恢复
- 正常读取：优先 Redis 热数据。
- 冷启动/缓存失效：
  1. 取最新快照 `S(version=k)`
  2. 拉取 `(k, latest]` 区间 `op_log`
  3. 回放得到最新全文，并回填 Redis。

### 4) 清理与归档
- `doc_op_log` 按版本区间归档到对象存储（如 MinIO），保留最近 N 天热日志。
- 老快照可保留“最近快照 + 每日一个里程碑快照”，降低存储成本。

## 为什么这个方案更适合 Markweave
- 匹配你当前 OT + Redis 的架构，改造成本低。
- 将“大字段频繁覆盖”变成“增量 append + 周期快照”，显著降低数据库写压。
- 天然支持历史回放、问题审计与跨机房恢复。

## 渐进式落地路径（建议 4 步）
1. **双写阶段**：继续写 `doc.content`，同时异步写 `doc_op_log`。
2. **快照阶段**：引入 `doc_snapshot` 定时/阈值快照任务。
3. **读切换阶段**：恢复逻辑优先“快照 + op 回放”，`doc.content` 仅兜底。
4. **收敛阶段**：降低 `doc.content` 写频，最终只保留“最后一次稳定快照”或迁移为冗余字段。

## 参数建议（初始值）
- 快照间隔：每 200 次操作或每 3 分钟（取先到者）。
- 热日志窗口：Redis 保留最近 500~1000 条 OT 记录。
- 批量落库：按 docId 聚合，100ms~500ms 批量刷盘。
- 幂等键：`doc_id + version` 唯一索引，防止重复消费。

## 额外建议
- 对超大文档（> 1~2MB）可进一步做“分片快照”（按段落/块）。
- 若未来做 CRDT，可复用“快照 + 事件流”存储骨架，仅替换 `op_json` 语义。
